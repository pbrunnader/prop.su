{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf400
{\fonttbl\f0\fswiss\fcharset0 ArialMT;\f1\froman\fcharset0 Times-Roman;}
{\colortbl;\red255\green255\blue255;\red38\green38\blue38;}
\paperw11900\paperh16840\margl1440\margr1440\vieww23040\viewh12460\viewkind1
\deftab720
\pard\pardeftab720\sa240

\f0\fs22 \cf0 Argue whether these two macros can be implemented as functions, Why?, Why not? How? (approximately 500 words).\
Functions are \cf2 executed at run time. They take arguments and \cf0 first evaluate these, then the body of the function is evaluated using this data to produce new\cf2  data. Therefore (conceptually) a function can be replaced by its resulting value.\cf0  \
\pard\pardeftab720\sl360\sa280
\cf0 Macros are executed at compile time, they take arguments, which are passed without being evaluated. This can lead to the evaluation of the arguments for multiple times or not at all. A macro is a piece of code that gets replaced with/transformed to another piece of code. \cf2 Therefore (conceptually) a macro can be replaced by its resulting code.\cf0  A disadvantage of a macro is for example, that if expressions with side effects get passed as parameters to a macro, the macro won't operate as expected, as the arguments are not evaluated.
\f1\fs26 \

\f0\fs22 Predefined macros in Clojure are for example: quote, let, recur\'85\
In our safe example, the macro would not be possible to get handled as a function. If our safe example would be a function, the arguments [s (FileReader. (File. "file.txt"))] and (. s read) would always be evaluated before the function runs. Which would result in an error.\
For the SQL-like macro example it would be possible to create a set of functions. These functions would be executed at run time. The return values of each function would replace the function and therefore passed to the next function and so on.\
}